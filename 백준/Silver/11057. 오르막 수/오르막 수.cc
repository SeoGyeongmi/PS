#include <stdio.h>

int main() {
    int a[1001][10]={0};
    int N;
    scanf("%d", &N);

    for(int i=0; i<=9; i++) 
        a[1][i] = 1;

    for(int i=2; i<=N; i++){
        // printf("길이가 %d일 때 계산\n", i);
        for(int j=0; j<=9; j++){
            for(int k=0; k<=j; k++)
                a[i][j] += a[i-1][k]%10007;
        }
    }


    int total=0;
    for(int i=0; i<=9; i++)
        total += a[N][i];

    printf("%d\n", total%10007);
    return 0;
}

/*
일차원 배열이 가능한 이유 - 원래는 길이, 끝자리 수 두 가지 변수가 있으니 2차원 배열을 사용해야 하는 것 아닌가?
길이에 대해서는 과거의 일련의 데이터가 사실 필요없다.(바로 직전 것만 있으면 됨. 직전의 데이터가 이전 데이터들의 누적합이기 때문이다.)
따라서 끝자리로만 구분하면 됨 -> 1차원 배열 하나를 계속 덮어쓰기 하면 됨.


일단 2차원 배열로 먼저 풀어보기
*/